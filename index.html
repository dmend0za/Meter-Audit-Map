<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meter Audit Map</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif;
        }
        #map { 
            position: absolute; 
            top: 0; 
            bottom: 0; 
            width: 100%; 
        }
        .mapboxgl-popup-content {
            padding: 15px;
            max-width: 300px;
        }
        .popup-header {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        .popup-info {
            margin-bottom: 8px;
            font-size: 14px;
        }
        .popup-label {
            font-weight: bold;
            color: #666;
        }
        .audit-button {
            background-color: #007cbf;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-top: 10px;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        .audit-button:hover {
            background-color: #005a87;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .error {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #f5c6cb;
            z-index: 1000;
        }
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 14px;
            z-index: 1000;
        }
        .stats-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }
        .refresh-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: #28a745;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .refresh-button:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="loading" class="loading">Loading meter locations...</div>
    <div id="error" class="error" style="display: none;"></div>
    <div id="stats" class="stats">
        <div class="stats-title">Audit Progress</div>
        <div id="total-meters">Total Meters: 0</div>
        <div id="pending-meters">Pending: 0</div>
        <div id="completed-meters">Completed: 0</div>
    </div>
    <button id="refresh-button" class="refresh-button" onclick="refreshData()">Refresh Data</button>

    <script>
        // Configuration
        const MAPBOX_TOKEN = 'pk.eyJ1IjoiZmllbGRzZW5zZSIsImEiOiJjbWMwb2ljY3YwNGFoMnJvaXN5c2xnMnR6In0.wc3C3TrsgsfyLf5ZJqHpnA';
        const FILLOUT_FORM_BASE_URL = 'https://form.fillout.com/t/aKNfdeajwuus';
        const GEOJSON_URL = 'https://raw.githubusercontent.com/dmend0za/Meter-Audit-Map/main/MetersInsp.geojson';
        const GOOGLE_SHEETS_URL = 'https://docs.google.com/spreadsheets/d/15dpFfp3H33r5ycWW3hwysAPkQFLO4Sjc0JhXuzkv_Ek/edit?gid=0#gid=0';
        const GOOGLE_SHEETS_CSV_URL = 'https://docs.google.com/spreadsheets/d/15dpFfp3H33r5ycWW3hwysAPkQFLO4Sjc0JhXuzkv_Ek/export?format=csv&gid=0';
        
        let map;
        let allMeters = [];
        let completedMeterIds = new Set();
        let currentPopup = null; // Store reference to current popup
        let statusCheckInterval = null; // For periodic status checking

        // Initialize map
        function initializeMap() {
            try {
                mapboxgl.accessToken = MAPBOX_TOKEN;
                
                map = new mapboxgl.Map({
                    container: 'map',
                    style: 'mapbox://styles/mapbox/satellite-streets-v12',
                    center: [-78.095, 35.628], // Centered on the sample coordinates
                    zoom: 12,
                    attributionControl: true
                });

                map.on('load', function () {
                    document.getElementById('loading').style.display = 'none';
                    loadMeterData();
                });

                map.on('error', function(e) {
                    showError('Map failed to load: ' + e.error.message);
                });

            } catch (error) {
                showError('Failed to initialize map: ' + error.message);
            }
        }

        // Load meter data from GeoJSON
        async function loadMeterData() {
            try {
                console.log('Attempting to load data from:', GEOJSON_URL);
                const response = await fetch(GEOJSON_URL);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}. Please ensure MetersInsp.geojson file exists in your GitHub repository.`);
                }
                
                const data = await response.json();
                console.log('Data loaded successfully:', data);
                
                if (!data.features || !Array.isArray(data.features)) {
                    throw new Error('Invalid GeoJSON format: features array not found');
                }
                
                allMeters = data.features;
                console.log(`Loaded ${allMeters.length} meters`);
                
                // Check completed meters from localStorage
                const stored = localStorage.getItem('completedMeters');
                if (stored) {
                    completedMeterIds = new Set(JSON.parse(stored));
                    console.log(`Found ${completedMeterIds.size} completed meters in local storage`);
                }
                
                addMarkersToMap();
                updateStats();
                
                // Start periodic status checking
                startStatusChecking();
                
            } catch (error) {
                console.error('Error loading meter data:', error);
                showError('Failed to load meter data: ' + error.message + '\n\nPlease ensure the MetersInsp.geojson file exists in your GitHub repository.');
            }
        }

        // Add markers to map
        function addMarkersToMap() {
            // Filter out completed meters
            const pendingMeters = allMeters.filter(meter => 
                !completedMeterIds.has(meter.properties.name)
            );

            // Create GeoJSON source
            const geojsonData = {
                type: 'FeatureCollection',
                features: pendingMeters
            };

            // Add source if it doesn't exist
            if (map.getSource('meters')) {
                map.getSource('meters').setData(geojsonData);
            } else {
                map.addSource('meters', {
                    type: 'geojson',
                    data: geojsonData,
                    cluster: true,
                    clusterMaxZoom: 14,
                    clusterRadius: 50
                });

                // Add cluster circles
                map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: 'meters',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#51bbd6',
                            100,
                            '#f1c40f',
                            750,
                            '#f28cb1'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            20,
                            100,
                            30,
                            750,
                            40
                        ]
                    }
                });

                // Add cluster count labels
                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: 'meters',
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    }
                });

                // Add individual meter points
                map.addLayer({
                    id: 'unclustered-point',
                    type: 'circle',
                    source: 'meters',
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-color': '#e74c3c',
                        'circle-radius': 8,
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff'
                    }
                });
            }

            // Add click handlers
            setupClickHandlers();
        }

        // Setup click handlers
        function setupClickHandlers() {
            // Click on clusters to zoom
            map.on('click', 'clusters', (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['clusters']
                });
                const clusterId = features[0].properties.cluster_id;
                map.getSource('meters').getClusterExpansionZoom(
                    clusterId,
                    (err, zoom) => {
                        if (err) return;
                        map.easeTo({
                            center: features[0].geometry.coordinates,
                            zoom: zoom
                        });
                    }
                );
            });

            // Click on individual meters to show popup
            map.on('click', 'unclustered-point', (e) => {
                const meter = e.features[0];
                showMeterPopup(meter, e.lngLat);
            });

            // Change cursor on hover
            map.on('mouseenter', 'clusters', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'clusters', () => {
                map.getCanvas().style.cursor = '';
            });
            map.on('mouseenter', 'unclustered-point', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'unclustered-point', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // Show meter popup with details
        function showMeterPopup(meter, coordinates) {
            const props = meter.properties;
            
            console.log('Full meter properties:', props);
            console.log('Description object:', props.description);
            
            // Extract data from the HTML description
            let htmlString = '';
            if (props.description && typeof props.description === 'object') {
                htmlString = props.description.value || props.description;
            } else if (typeof props.description === 'string') {
                htmlString = props.description;
            }
            
            console.log('HTML string to parse:', htmlString ? htmlString.substring(0, 200) + '...' : 'EMPTY');
            
            const meterData = extractMeterData(htmlString);
            
            console.log('Meter data for popup:', meterData);
            console.log('Audit link:', meterData.link);
            
            // Create popup content without inline onclick handlers
            const popupContent = `
                <div class="popup-header">${meterData.address || 'Unknown Address'}</div>
                <div class="popup-info">
                    <span class="popup-label">Meter Number:</span> ${meterData.meterNumber || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Location ID:</span> ${meterData.locId || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Meter Type:</span> ${meterData.meterType || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Meter Style:</span> ${meterData.meterStyle || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Customer:</span> ${meterData.customer || 'N/A'}
                </div>
                <button class="audit-button" id="audit-btn-${props.name}">
                    Start Audit
                </button>
            `;

            // Close any existing popup
            if (currentPopup) {
                currentPopup.remove();
            }

            // Create new popup
            currentPopup = new mapboxgl.Popup({
                closeOnClick: true,
                closeButton: true
            })
            .setLngLat(coordinates)
            .setHTML(popupContent)
            .addTo(map);

            // Add event listener to the button after popup is added to DOM
            // Use setTimeout to ensure DOM is fully rendered
            setTimeout(() => {
                const button = document.getElementById(`audit-btn-${props.name}`);
                console.log('Looking for button with ID:', `audit-btn-${props.name}`);
                console.log('Button found:', button);
                
                if (button) {
                    console.log('Adding click event listener to button');
                    
                    // Remove any existing event listeners by cloning the button
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);
                    
                    // Add single event listener to the clean button
                    newButton.addEventListener('click', (e) => {
                        console.log('Button clicked!');
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Disable button immediately to prevent multiple clicks
                        newButton.disabled = true;
                        newButton.textContent = 'Opening...';
                        
                        startAudit(props.name, meterData.link);
                    }, { once: true }); // Use 'once' option to ensure it only fires once
                    
                    // Also add visual feedback on hover
                    newButton.style.cursor = 'pointer';
                } else {
                    console.error('Button not found in DOM');
                }
            }, 100);

            // Clear reference when popup is closed
            currentPopup.on('close', () => {
                currentPopup = null;
            });
        }

        // Extract meter data from HTML description
        function extractMeterData(htmlString) {
            console.log('Extracting data from HTML. Type:', typeof htmlString, 'Length:', htmlString ? htmlString.length : 0);
            
            // Handle case where htmlString is undefined or empty
            if (!htmlString || typeof htmlString !== 'string') {
                console.log('No valid HTML string provided, returning empty data object');
                return {
                    address: '',
                    meterNumber: '',
                    locId: '',
                    meterType: '',
                    meterStyle: '',
                    customer: '',
                    link: ''
                };
            }
            
            console.log('HTML content preview:', htmlString.substring(0, 500) + '...');
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            
            const data = {};
            const rows = doc.querySelectorAll('tr');
            
            console.log('Found', rows.length, 'table rows');
            
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                if (cells.length === 2) {
                    const key = cells[0].textContent.trim();
                    const value = cells[1].textContent.trim();
                    
                    console.log(`Row ${index}: ${key} = ${value}`);
                    
                    switch(key) {
                        case 'PHYS_ADD':
                            data.address = value;
                            break;
                        case 'Meter_Numb':
                            data.meterNumber = value;
                            break;
                        case 'Loc_ID':
                        case 'LOCID':
                            data.locId = value;
                            break;
                        case 'Meter_Type':
                            data.meterType = value;
                            break;
                        case 'Meter_Styl':
                            data.meterStyle = value;
                            break;
                        case 'Customer_N':
                            data.customer = value;
                            break;
                        case 'LINK':
                            console.log('Processing LINK row...');
                            // Get the link element and extract href
                            const linkElement = cells[1].querySelector('a');
                            if (linkElement) {
                                let href = linkElement.getAttribute('href');
                                console.log('Found href attribute:', href);
                                // Decode HTML entities
                                if (href) {
                                    href = href.replace(/&amp;/g, '&');
                                    data.link = href;
                                    console.log('Decoded href:', href);
                                }
                            }
                            // Also try to extract from plain text if no link element found
                            if (!data.link) {
                                let cellText = cells[1].textContent.trim();
                                console.log('Trying to extract from cell text:', cellText);
                                if (cellText.startsWith('https://form.fillout.com')) {
                                    // Decode HTML entities in the text
                                    cellText = cellText.replace(/&amp;/g, '&');
                                    data.link = cellText;
                                    console.log('Extracted link from text:', cellText);
                                }
                            }
                            // Also check innerHTML for the link
                            if (!data.link) {
                                const innerHTML = cells[1].innerHTML;
                                console.log('Checking innerHTML:', innerHTML);
                                const linkMatch = innerHTML.match(/href="([^"]*)"/);
                                if (linkMatch) {
                                    let href = linkMatch[1];
                                    href = href.replace(/&amp;/g, '&');
                                    data.link = href;
                                    console.log('Extracted link from innerHTML:', href);
                                }
                            }
                            break;
                    }
                }
            });
            
            console.log('Extracted data so far:', data);
            
            // If we still don't have a proper link, construct it from the data
            if (!data.link || !data.link.startsWith('https://form.fillout.com')) {
                console.log('No valid link found, constructing from data...');
                if (data.address && data.meterNumber && data.locId && data.meterType && data.meterStyle) {
                    // Construct the URL with proper encoding
                    const params = new URLSearchParams({
                        'Address': data.address,
                        'Meter_Number': data.meterNumber,
                        'Meter_Type': data.meterType,
                        'Meter_Style': data.meterStyle,
                        'Loc_ID': data.locId
                    });
                    data.link = `${FILLOUT_FORM_BASE_URL}?${params.toString()}`;
                    console.log('Constructed link:', data.link);
                } else {
                    console.log('Missing required data for link construction:', {
                        address: data.address,
                        meterNumber: data.meterNumber,
                        locId: data.locId,
                        meterType: data.meterType,
                        meterStyle: data.meterStyle
                    });
                }
            }
            
            console.log('Final extracted data:', data);
            return data;
        }

        // Start audit function - opens link without marking as completed
        function startAudit(meterName, auditLink) {
            console.log('Starting audit for meter:', meterName);
            console.log('Audit link:', auditLink);
            
            if (!auditLink || auditLink === 'undefined' || auditLink === 'null') {
                showError('Unable to generate audit link for this meter. Please check the meter data.');
                return;
            }
            
            // Validate the link format
            if (!auditLink.startsWith('https://form.fillout.com')) {
                showError('Invalid audit link format. Expected FillOut form URL.');
                return;
            }
            
            // Close popup
            if (currentPopup) {
                currentPopup.remove();
                currentPopup = null;
            }
            
            // Open the audit form in a new tab/window (do NOT mark as completed yet)
            try {
                console.log('Attempting to open:', auditLink);
                const newWindow = window.open(auditLink, '_blank', 'noopener,noreferrer');
                
                // Check if window.open was successful
                if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
                    // Popup blocker might have prevented opening
                    console.log('Popup blocked, trying alternative method...');
                    // Create a temporary link and click it
                    const tempLink = document.createElement('a');
                    tempLink.href = auditLink;
                    tempLink.target = '_blank';
                    tempLink.rel = 'noopener noreferrer';
                    document.body.appendChild(tempLink);
                    tempLink.click();
                    document.body.removeChild(tempLink);
                } else {
                    console.log('Audit form opened successfully with window.open()');
                }
                
            } catch (error) {
                console.error('Error opening audit link:', error);
                showError('Error opening audit form: ' + error.message);
            }
        }

        // Check Google Sheets for completed audits
        async function checkCompletedAudits() {
            try {
                console.log('Checking for completed audits...');
                const response = await fetch(GOOGLE_SHEETS_CSV_URL);
                
                if (!response.ok) {
                    console.log('Could not fetch spreadsheet data:', response.status);
                    return;
                }
                
                const csvData = await response.text();
                const lines = csvData.split('\n');
                
                if (lines.length < 2) {
                    console.log('No data found in spreadsheet');
                    return;
                }
                
                // Parse CSV headers
                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                console.log('Spreadsheet headers:', headers);
                
                // Find the relevant column indices
                const meterNumberIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('meter') && h.toLowerCase().includes('number')
                );
                const statusIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('status')
                );
                
                console.log('Meter Number column index:', meterNumberIndex);
                console.log('Status column index:', statusIndex);
                
                if (meterNumberIndex === -1 || statusIndex === -1) {
                    console.log('Required columns not found in spreadsheet');
                    return;
                }
                
                // Create a new set of currently completed meters from the spreadsheet
                const currentlyCompleted = new Set();
                
                // Check each row for completed status
                for (let i = 1; i < lines.length; i++) {
                    const row = lines[i].split(',').map(cell => cell.trim().replace(/"/g, ''));
                    
                    if (row.length > Math.max(meterNumberIndex, statusIndex)) {
                        const meterNumber = row[meterNumberIndex];
                        const status = row[statusIndex];
                        
                        console.log(`Row ${i}: Meter=${meterNumber}, Status=${status}`);
                        
                        if (meterNumber && status && status.toLowerCase() === 'complete') {
                            currentlyCompleted.add(meterNumber);
                        }
                    }
                }
                
                console.log('Currently completed meters from spreadsheet:', [...currentlyCompleted]);
                console.log('Previously completed meters in memory:', [...completedMeterIds]);
                
                // Find newly completed meters
                const newCompletions = [...currentlyCompleted].filter(meter => !completedMeterIds.has(meter));
                
                // Find meters that are no longer completed (status removed/changed)
                const noLongerCompleted = [...completedMeterIds].filter(meter => !currentlyCompleted.has(meter));
                
                let mapNeedsUpdate = false;
                
                if (newCompletions.length > 0) {
                    console.log('Found newly completed meters:', newCompletions);
                    newCompletions.forEach(meter => completedMeterIds.add(meter));
                    mapNeedsUpdate = true;
                    showInfo(`${newCompletions.length} audit(s) completed! Markers removed.`);
                }
                
                if (noLongerCompleted.length > 0) {
                    console.log('Found meters no longer completed:', noLongerCompleted);
                    noLongerCompleted.forEach(meter => completedMeterIds.delete(meter));
                    mapNeedsUpdate = true;
                    showInfo(`${noLongerCompleted.length} meter(s) status changed. Markers restored.`);
                }
                
                if (mapNeedsUpdate) {
                    // Save to localStorage
                    localStorage.setItem('completedMeters', JSON.stringify([...completedMeterIds]));
                    
                    // Update map
                    addMarkersToMap();
                    updateStats();
                }
                
            } catch (error) {
                console.error('Error checking completed audits:', error);
            }
        }

        // Start periodic status checking
        function startStatusChecking() {
            // Check immediately
            checkCompletedAudits();
            
            // Then check every 30 seconds
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            
            statusCheckInterval = setInterval(() => {
                checkCompletedAudits();
            }, 30000); // Check every 30 seconds
        }

        // Stop status checking
        function stopStatusChecking() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
            }
        }

        // Update statistics
        function updateStats() {
            const total = allMeters.length;
            const completed = completedMeterIds.size;
            const pending = total - completed;
            
            document.getElementById('total-meters').textContent = `Total Meters: ${total}`;
            document.getElementById('pending-meters').textContent = `Pending: ${pending}`;
            document.getElementById('completed-meters').textContent = `Completed: ${completed}`;
        }

        // Refresh data
        function refreshData() {
            document.getElementById('loading').style.display = 'block';
            // Also check for completed audits when refreshing
            checkCompletedAudits();
            loadMeterData();
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            errorDiv.style.backgroundColor = '#f8d7da';
            errorDiv.style.color = '#721c24';
            document.getElementById('loading').style.display = 'none';
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 10000);
        }

        // Show info message
        function showInfo(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            errorDiv.style.backgroundColor = '#d4edda';
            errorDiv.style.color = '#155724';
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Check if Mapbox GL JS loaded successfully
        function checkMapboxLoad() {
            if (typeof mapboxgl === 'undefined') {
                showError('Mapbox GL JS failed to load. Please check your internet connection.');
                return false;
            }
            return true;
        }

        // Initialize when page loads
        window.addEventListener('load', function() {
            if (checkMapboxLoad()) {
                initializeMap();
            }
        });

        // Handle offline/online events
        window.addEventListener('online', function() {
            refreshData();
        });

        window.addEventListener('offline', function() {
            showError('You are currently offline. Some features may not work properly.');
        });

        // Clean up intervals when page unloads
        window.addEventListener('beforeunload', function() {
            stopStatusChecking();
        });
    </script>
</body>
</html>
