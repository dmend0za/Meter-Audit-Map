<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meter Audit Map</title>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #f5f5f5;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-button {
            background: white;
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .control-button:hover {
            background: #f8f9fa;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            max-width: 200px;
            font-size: 12px;
        }

        .legend-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .legend-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 10px;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid;
            flex-shrink: 0;
        }

        .legend-item span {
            color: #333;
            font-size: 13px;
        }
        
        /* Special styling for Key Account legend item */
        .special-item {
            background-color: rgba(201, 210, 218, 0.2);
            padding: 4px 6px;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        
        .legend-divider {
            height: 1px;
            background-color: #ddd;
            margin: 8px 0;
        }
        
        /* Completed notice styling */
        .completed-notice {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #e9ecef;
        }

        .stats {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            gap: 15px;
        }

        .stat-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            min-width: 80px;
        }

        .stat-number {
            display: block;
            font-size: 24px;
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 2000;
            font-weight: 500;
            color: #374151;
        }

        /* Popup styles */
        .mapboxgl-popup-content {
            padding: 0;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .popup-header {
            background: #2563eb;
            color: white;
            padding: 12px 15px;
            font-weight: bold;
            font-size: 14px;
            border-radius: 8px 8px 0 0;
        }

        .popup-info {
            padding: 8px 15px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 13px;
        }

        .popup-info:last-child {
            border-bottom: none;
        }

        .popup-label {
            font-weight: 600;
            color: #374151;
        }

        .audit-button {
            background: #10b981;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 10px 15px 15px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            width: calc(100% - 30px);
            transition: background 0.2s ease;
        }

        .audit-button:hover {
            background: #059669;
        }

        /* Info message styles */
        .info-message {
            position: absolute;
            top: 100px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1500;
            font-weight: 500;
            max-width: 300px;
            animation: slideIn 0.3s ease;
        }

        .error-message {
            position: absolute;
            top: 100px;
            right: 20px;
            background: #ef4444;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1500;
            font-weight: 500;
            max-width: 300px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .controls {
                top: 10px;
                right: 10px;
                gap: 8px;
            }

            .control-button {
                padding: 10px 12px;
                font-size: 12px;
            }

            .stats {
                top: 10px;
                left: 10px;
                gap: 10px;
            }

            .stat-item {
                padding: 10px;
                min-width: 60px;
            }

            .stat-number {
                font-size: 18px;
            }

            .stat-label {
                font-size: 11px;
            }

            .legend {
                bottom: 10px;
                right: 10px;
                padding: 12px;
                max-width: 160px;
                font-size: 11px;
            }

            .legend-title {
                font-size: 12px;
            }

            .legend-item span {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <nav class="controls" role="navigation" aria-label="Map controls">
        <button class="control-button" onclick="refreshData()" aria-label="Refresh map data">üîÑ Refresh Data</button>
        <button class="control-button" onclick="locateUser()" aria-label="Center map on your location">üìç My Location</button>
    </nav>

    <section class="stats" role="region" aria-label="Meter statistics">
        <div class="stat-item">
            <span class="stat-number" id="total-meters">0</span>
            <span class="stat-label">Total Meters</span>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="pending-meters">0</span>
            <span class="stat-label">Pending Audits</span>
        </div>
    </section>

    <aside class="legend" role="complementary" aria-label="Map legend">
        <!-- Legend will be populated by JavaScript -->
    </aside>

    <main id="map" role="main" aria-label="Interactive meter location map"></main>

    <div id="loading">Loading meter locations...</div>

    <script>
        // Configuration
        mapboxgl.accessToken = 'pk.eyJ1IjoiZG1lbmRvemEiLCJhIjoiY20ycGMzcjB6MDUzMDJyczRrNnZicGNheiJ9.jzl3oIjm1-MXakmN5cPy7w';
        const GEOJSON_URL = 'https://dmend0za.github.io/Meter-Audit-Map/MeterInsp.geojson';
        const GOOGLE_SHEETS_CSV_URL = 'https://docs.google.com/spreadsheets/d/1wFGrinSXWHRYplgOLgD3tjx4-c0lv4JXncshfBhoBwc/export?format=csv&gid=0';

        // Global variables
        let map;
        let allMeters = [];
        let completedMeterIds = new Set();
        let userLocation = null;
        let statusCheckInterval = null;

        // Initialize map
        function initMap() {
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/satellite-v9',
                center: [-78.0, 35.8], // North Carolina
                zoom: 10
            });

            map.on('load', () => {
                setupMapLayers();
                loadMeterData();
                setupUserLocation();
                createLegend();
            });

            // Add navigation controls
            map.addControl(new mapboxgl.NavigationControl(), 'top-left');
        }

        // Setup map layers and clustering
        function setupMapLayers() {
            // Add source for meter data
            map.addSource('meters', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                },
                cluster: true,
                clusterMaxZoom: 14,
                clusterRadius: 50
            });

            // Add cluster circles
            map.addLayer({
                id: 'clusters',
                type: 'circle',
                source: 'meters',
                filter: ['has', 'point_count'],
                paint: {
                    'circle-color': [
                        'step',
                        ['get', 'point_count'],
                        '#51bbd6',
                        100,
                        '#f1f075',
                        750,
                        '#f28cb1'
                    ],
                    'circle-radius': [
                        'step',
                        ['get', 'point_count'],
                        20,
                        100,
                        30,
                        750,
                        40
                    ]
                }
            });

            // Add cluster count labels
            map.addLayer({
                id: 'cluster-count',
                type: 'symbol',
                source: 'meters',
                filter: ['has', 'point_count'],
                layout: {
                    'text-field': '{point_count_abbreviated}',
                    'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                    'text-size': 12
                }
            });

            // Add individual meter points with special Key Account handling
            map.addLayer({
                id: 'unclustered-point',
                type: 'circle',
                source: 'meters',
                filter: ['!', ['has', 'point_count']],
                paint: {
                    'circle-color': [
                        'case',
                        ['get', 'isKeyAccount'], '#c9d2da', // Gray-blue for Key Account meters
                        ['==', ['get', 'meterStyle'], '12S'], '#006400', // Dark Green
                        ['==', ['get', 'meterStyle'], '9S'], '#ef4444',   // Red
                        ['==', ['get', 'meterStyle'], '4S'], '#7f00ff',   // Purple
                        ['==', ['get', 'meterStyle'], '2S'], '#3b82f6',   // Blue
                        ['==', ['get', 'meterStyle'], '6S'], '#eab308',   // Yellow
                        ['==', ['get', 'meterStyle'], '1S'], '#f97316',   // Orange
                        ['==', ['get', 'meterStyle'], '35S'], '#a16207',  // Brown
                        ['==', ['get', 'meterStyle'], '16S'], '#000000',  // Black
                        '#ffffff' // White for other/unknown values
                    ],
                    'circle-radius': [
                        'case',
                        ['get', 'isKeyAccount'], 10, // Slightly larger for Key Accounts
                        8 // Regular size for others
                    ],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': [
                        'case',
                        ['get', 'isKeyAccount'], '#000000', // Black outline for Key Account
                        ['==', ['get', 'meterStyle'], '16S'], '#ffffff', // White outline for black marker
                        ['in', ['get', 'meterStyle'], ['literal', ['12S', '9S', '4S', '2S', '6S', '1S', '35S']]], '#ffffff', // White outline for colored markers
                        '#333333' // Dark outline for white "Other" markers
                    ]
                }
            });

            // Add red X overlay for completed Key Account meters
            map.addLayer({
                id: 'completed-key-account-x',
                type: 'symbol',
                source: 'meters',
                filter: ['all', ['!', ['has', 'point_count']], ['get', 'isKeyAccount'], ['get', 'isCompleted']],
                layout: {
                    'text-field': '‚úï',
                    'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                    'text-size': 20, // Increased from 14 to 20 for better visibility
                    'text-anchor': 'center',
                    'text-allow-overlap': true
                },
                paint: {
                    'text-color': '#ff0000',
                    'text-halo-color': '#ffffff',
                    'text-halo-width': 2 // Increased halo width for better contrast
                }
            });

            // Add meter labels
            map.addLayer({
                id: 'meter-labels',
                type: 'symbol',
                source: 'meters',
                filter: ['!', ['has', 'point_count']],
                layout: {
                    'text-field': ['get', 'name'],
                    'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                    'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                    'text-radial-offset': 0.8,
                    'text-justify': 'auto',
                    'text-size': 10
                },
                paint: {
                    'text-color': '#333',
                    'text-halo-color': '#ffffff',
                    'text-halo-width': 1
                }
            });

            // Setup click handlers
            map.on('click', 'clusters', (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['clusters']
                });
                const clusterId = features[0].properties.cluster_id;
                map.getSource('meters').getClusterExpansionZoom(clusterId, (err, zoom) => {
                    if (err) return;
                    map.easeTo({
                        center: features[0].geometry.coordinates,
                        zoom: zoom
                    });
                });
            });

            map.on('click', 'unclustered-point', (e) => {
                const coordinates = e.features[0].geometry.coordinates.slice();
                const meter = e.features[0];
                
                // Ensure that if the map is zoomed out such that multiple
                // copies of the feature are visible, the popup appears
                // over the copy being pointed to.
                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                }

                showMeterPopup(meter, coordinates);
            });

            // Change cursor on hover
            map.on('mouseenter', 'clusters', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'clusters', () => {
                map.getCanvas().style.cursor = '';
            });
            map.on('mouseenter', 'unclustered-point', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'unclustered-point', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // Setup user location tracking
        function setupUserLocation() {
            if (!navigator.geolocation) {
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 60000
            };

            navigator.geolocation.watchPosition(
                (position) => {
                    userLocation = {
                        lng: position.coords.longitude,
                        lat: position.coords.latitude,
                        accuracy: position.coords.accuracy
                    };
                    
                    updateUserLocationMarker();
                },
                (error) => {
                    console.error('Error watching location:', error);
                },
                options
            );
        }

        // Update user location marker on map
        function updateUserLocationMarker() {
            if (!userLocation || !map.loaded()) return;

            // Remove existing user location layers if they exist
            if (map.getLayer('user-location')) {
                map.removeLayer('user-location');
            }
            if (map.getLayer('user-location-accuracy')) {
                map.removeLayer('user-location-accuracy');
            }
            if (map.getSource('user-location')) {
                map.removeSource('user-location');
            }

            // Add user location source
            map.addSource('user-location', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: [
                        {
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: [userLocation.lng, userLocation.lat]
                            },
                            properties: {
                                accuracy: userLocation.accuracy
                            }
                        }
                    ]
                }
            });

            // Add accuracy circle
            map.addLayer({
                id: 'user-location-accuracy',
                type: 'circle',
                source: 'user-location',
                paint: {
                    'circle-radius': {
                        stops: [
                            [0, 0],
                            [20, Math.max(userLocation.accuracy, 10)]
                        ],
                        base: 2
                    },
                    'circle-color': '#007cbf',
                    'circle-opacity': 0.2,
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#007cbf',
                    'circle-stroke-opacity': 0.5
                }
            });

            // Add user location dot
            map.addLayer({
                id: 'user-location',
                type: 'circle',
                source: 'user-location',
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#007cbf',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff'
                }
            });
        }

        // Center map on user location
        function locateUser() {
            if (!userLocation) {
                showError('Location not available. Please enable location services.');
                return;
            }

            map.flyTo({
                center: [userLocation.lng, userLocation.lat],
                zoom: 16,
                duration: 2000
            });

            showInfo(`Centered on your location (¬±${Math.round(userLocation.accuracy)}m)`);
        }

        // Load meter data from GeoJSON
        async function loadMeterData() {
            try {
                const response = await fetch(GEOJSON_URL);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}. Please ensure MeterInsp.geojson file exists in your GitHub repository.`);
                }
                
                const data = await response.json();
                
                if (!data.features || !Array.isArray(data.features)) {
                    throw new Error('Invalid GeoJSON format: features array not found');
                }
                
                allMeters = data.features;
                
                // Check completed meters from localStorage
                const stored = localStorage.getItem('completedMeters');
                if (stored) {
                    completedMeterIds = new Set(JSON.parse(stored));
                }
                
                addMarkersToMap();
                updateStats();
                
                // Start periodic status checking only on initial load (not on refresh)
                if (!statusCheckInterval) {
                    startStatusChecking();
                }
                
                // Only hide loading if this is NOT a refresh (initial load only)
                if (!window.isRefreshing) {
                    document.getElementById('loading').style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error loading meter data:', error);
                showError('Failed to load meter data: ' + error.message + '\n\nPlease ensure the MeterInsp.geojson file exists in your GitHub repository.');
                
                // Always hide loading on error
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Add markers to map
        function addMarkersToMap() {
            // Filter out completed meters but keep Key Account meters regardless of completion status
            const pendingMeters = allMeters.filter(meter => {
                const meterData = extractMeterData(meter.properties.description?.value || meter.properties.description || '');
                const isKeyAccount = meterData.keyAccount && meterData.keyAccount.toUpperCase() !== 'NULL';
                
                // Keep Key Account meters always, filter out completed non-Key Account meters
                return isKeyAccount || !completedMeterIds.has(meter.properties.name);
            }).map(meter => {
                // Extract meter style and key account info for styling
                const meterData = extractMeterData(meter.properties.description?.value || meter.properties.description || '');
                const isKeyAccount = meterData.keyAccount && meterData.keyAccount.toUpperCase() !== 'NULL';
                const isCompleted = completedMeterIds.has(meter.properties.name);
                
                // Add properties for styling
                return {
                    ...meter,
                    properties: {
                        ...meter.properties,
                        meterStyle: meterData.meterStyle || 'other',
                        isKeyAccount: isKeyAccount,
                        isCompleted: isCompleted
                    }
                };
            });

            // Create GeoJSON source
            const geojsonData = {
                type: 'FeatureCollection',
                features: pendingMeters
            };

            // Update the map source
            map.getSource('meters').setData(geojsonData);
        }

        // Show meter popup with details
        function showMeterPopup(meter, coordinates) {
            const props = meter.properties;
            
            // Extract data from the HTML description
            let htmlString = '';
            if (props.description && typeof props.description === 'object') {
                htmlString = props.description.value || props.description;
            } else if (typeof props.description === 'string') {
                // Check if it's a JSON string that needs parsing
                try {
                    const parsed = JSON.parse(props.description);
                    htmlString = parsed.value || props.description;
                } catch {
                    htmlString = props.description;
                }
            }
            
            const meterData = extractMeterData(htmlString);

            // Store the meter data globally with a unique key to avoid conflicts
            const dataKey = `meterData_${props.name}`;
            window[dataKey] = {
                name: props.name,
                link: meterData.link,
                timestamp: Date.now() // Add timestamp to track data freshness
            };
            
            // Also store as current for backward compatibility
            window.currentMeterData = window[dataKey];

            // Check completion status in real-time when creating popup
            const realTimeCompleted = completedMeterIds.has(props.name);
            
            // Create popup content - remove Start Audit button for completed meters
            const popupContent = `
                <div class="popup-header">${meterData.address || 'Unknown Address'}</div>
                <div class="popup-info">
                    <span class="popup-label">Meter Number:</span> ${meterData.meterNumber || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Location ID:</span> ${meterData.locId || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Meter Type:</span> ${meterData.meterType || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Meter Style:</span> ${meterData.meterStyle || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Volts:</span> ${meterData.volts || 'N/A'}
                </div>
                <div class="popup-info">
                    <span class="popup-label">Location Status:</span> ${meterData.locationStatus || 'N/A'}
                </div>
                ${(meterData.billingMultiplier && meterData.billingMultiplier !== '1' && meterData.billingMultiplier.toUpperCase() !== 'NULL') ? 
                    `<div class="popup-info">
                        <span class="popup-label">Billing Multiplier:</span> ${meterData.billingMultiplier}
                    </div>` : ''
                }
                ${(meterData.keyAccount && meterData.keyAccount.toUpperCase() !== 'NULL') ? 
                    `<div class="popup-info">
                        <span class="popup-label">Key Account:</span> ${meterData.keyAccount}
                    </div>` : ''
                }
                ${realTimeCompleted ? 
                    `<div class="completed-notice">
                        <span style="color: #28a745; font-weight: bold;">‚úì Audit Completed</span>
                    </div>` : 
                    `<button class="audit-button" onclick="startAuditWithId('${props.name}');">
                        Start Audit
                    </button>`
                }
            `;

            // Create popup and add to map
            const popup = new mapboxgl.Popup({
                closeOnClick: true,
                closeButton: true,
                maxWidth: '300px'
            })
                .setLngLat(coordinates)
                .setHTML(popupContent)
                .addTo(map);
        }

        // Extract meter data from HTML description
        function extractMeterData(htmlString) {
            const data = {};
            
            if (!htmlString || typeof htmlString !== 'string') {
                return data;
            }
            
            try {
                // Create a DOM parser to parse the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlString, 'text/html');
                
                // Find all table rows
                const rows = doc.querySelectorAll('tr');
                
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 2) {
                        const key = cells[0].textContent.trim();
                        const valueCell = cells[1];
                        
                        // Check if the cell contains a link
                        const link = valueCell.querySelector('a');
                        if (key === 'LINK' && link) {
                            // Get the href attribute
                            const href = link.getAttribute('href');
                            
                            // Decode HTML entities
                            const decodedHref = href.replace(/&amp;/g, '&');
                            
                            data.link = decodedHref;
                        } else {
                            const value = valueCell.textContent.trim();
                            
                            // Map the keys to more readable names
                            switch (key) {
                                case 'LOCID':
                                case 'Loc_ID':
                                    data.locId = value;
                                    break;
                                case 'PHYS_ADD':
                                    data.address = value;
                                    break;
                                case 'Meter_Numb':
                                    data.meterNumber = value;
                                    break;
                                case 'Meter_Type':
                                    data.meterType = value;
                                    break;
                                case 'Meter_Styl':
                                    data.meterStyle = value;
                                    break;
                                case 'volts':
                                    data.volts = value;
                                    break;
                                case 'location_s':
                                    data.locationStatus = value;
                                    break;
                                case 'Billing_Mu':
                                    data.billingMultiplier = value;
                                    break;
                                case 'Key_Accoun':
                                    data.keyAccount = value;
                                    break;
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error parsing meter data:', error);
            }
            
            return data;
        }

        // Start audit with meter ID
        function startAuditWithId(meterId) {
            const dataKey = `meterData_${meterId}`;
            const meterData = window[dataKey] || window.currentMeterData;
            
            if (!meterData || !meterData.link) {
                showError('Audit link not available for this meter.');
                return;
            }
            
            // Open the audit form in a new tab
            window.open(meterData.link, '_blank');
        }

        // Update statistics
        function updateStats() {
            const totalMeters = allMeters.length;
            const completedCount = completedMeterIds.size;
            const pendingCount = totalMeters - completedCount;
            
            document.getElementById('total-meters').textContent = totalMeters;
            document.getElementById('pending-meters').textContent = pendingCount;
        }

        // Create legend
        function createLegend() {
            const legend = document.querySelector('.legend');
            legend.innerHTML = `
                <h3 class="legend-title">Meter Styles</h3>
                <ul class="legend-list" role="list">
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #f97316; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>1S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #3b82f6; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>2S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #7f00ff; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>4S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #eab308; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>6S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #ef4444; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>9S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #006400; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>12S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #000000; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>16S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #a16207; border-color: #ffffff;" aria-hidden="true"></div>
                        <span>35S</span>
                    </li>
                    <li class="legend-item" role="listitem">
                        <div class="legend-color" style="background-color: #ffffff; border-color: #333333;" aria-hidden="true"></div>
                        <span>Other</span>
                    </li>
                </ul>
                <div class="legend-divider" aria-hidden="true"></div>
                <ul class="legend-list" role="list">
                    <li class="legend-item special-item" role="listitem">
                        <div class="legend-color" style="background-color: #c9d2da; border-color: #000000;" aria-hidden="true"></div>
                        <span><strong>Key Account</strong></span>
                    </li>
                </ul>
            `;
        }

        // Check Google Sheets for completed audits
        async function checkCompletedAudits() {
            try {
                const response = await fetch(GOOGLE_SHEETS_CSV_URL);
                
                if (!response.ok) {
                    return;
                }
                
                const csvData = await response.text();
                const lines = csvData.split('\n');
                
                if (lines.length < 2) {
                    return;
                }
                
                // Parse CSV headers
                const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                
                // Find the relevant column indices - be more specific about which columns to use
                const meterNumberIndex = headers.findIndex(h => 
                    h === 'Meter Number' // Exact match for the FillOut form field
                );
                const statusIndex = headers.findIndex(h => 
                    h === 'Status' // Exact match for the first Status column
                );
                
                // Fallback to broader search if exact matches not found
                const fallbackMeterIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('meter') && h.toLowerCase().includes('number')
                );
                const fallbackStatusIndex = headers.findIndex(h => 
                    h.toLowerCase().includes('status')
                );
                
                const finalMeterIndex = meterNumberIndex !== -1 ? meterNumberIndex : fallbackMeterIndex;
                const finalStatusIndex = statusIndex !== -1 ? statusIndex : fallbackStatusIndex;
                
                if (finalMeterIndex === -1 || finalStatusIndex === -1) {
                    return;
                }
                
                // Create a new set of currently completed meters from the spreadsheet
                const currentlyCompleted = new Set();
                
                // Parse CSV properly handling quoted fields with commas
                function parseCSVLine(line) {
                    const result = [];
                    let current = '';
                    let inQuotes = false;
                    let i = 0;
                    
                    while (i < line.length) {
                        const char = line[i];
                        const nextChar = line[i + 1];
                        
                        if (char === '"') {
                            if (inQuotes && nextChar === '"') {
                                // Escaped quote
                                current += '"';
                                i += 2;
                            } else {
                                // Toggle quote state
                                inQuotes = !inQuotes;
                                i++;
                            }
                        } else if (char === ',' && !inQuotes) {
                            // Field separator
                            result.push(current.trim());
                            current = '';
                            i++;
                        } else {
                            current += char;
                            i++;
                        }
                    }
                    
                    // Add the last field
                    result.push(current.trim());
                    return result;
                }
                
                // Check each row for completed status
                for (let i = 1; i < lines.length; i++) {
                    const rawLine = lines[i];
                    if (!rawLine.trim()) continue; // Skip empty lines
                    
                    const row = parseCSVLine(rawLine);
                    
                    if (row.length > Math.max(finalMeterIndex, finalStatusIndex)) {
                        const meterNumber = row[finalMeterIndex]?.trim().replace(/"/g, '') || '';
                        let status = row[finalStatusIndex]?.trim().replace(/"/g, '') || '';
                        
                        // Fallback: check adjacent columns for status if primary is empty
                        if (!status || status.length === 0) {
                            // Check one column to the right
                            if (finalStatusIndex + 1 < row.length && row[finalStatusIndex + 1]) {
                                status = row[finalStatusIndex + 1].trim().replace(/"/g, '');
                            }
                            // Check one column to the left  
                            else if (finalStatusIndex - 1 >= 0 && row[finalStatusIndex - 1]) {
                                status = row[finalStatusIndex - 1].trim().replace(/"/g, '');
                            }
                        }
                        
                        if (meterNumber && meterNumber.length > 0) {
                            if (status && status.length > 0) {
                                if (status.toLowerCase() === 'complete') {
                                    currentlyCompleted.add(meterNumber);
                                }
                            }
                        }
                    }
                }
                
                // Find newly completed meters
                const newCompletions = [...currentlyCompleted].filter(meter => !completedMeterIds.has(meter));
                
                // Find meters that are no longer completed (status removed/changed)
                const noLongerCompleted = [...completedMeterIds].filter(meter => !currentlyCompleted.has(meter));
                
                let mapNeedsUpdate = false;
                
                if (newCompletions.length > 0) {
                    newCompletions.forEach(meter => completedMeterIds.add(meter));
                    mapNeedsUpdate = true;
                    showInfo(`${newCompletions.length} audit(s) completed! Markers removed.`);
                }
                
                if (noLongerCompleted.length > 0) {
                    noLongerCompleted.forEach(meter => completedMeterIds.delete(meter));
                    mapNeedsUpdate = true;
                    showInfo(`${noLongerCompleted.length} meter(s) status changed. Markers restored.`);
                }
                
                if (mapNeedsUpdate) {
                    // Save to localStorage
                    localStorage.setItem('completedMeters', JSON.stringify([...completedMeterIds]));
                    
                    // Update map
                    addMarkersToMap();
                    updateStats();
                }
                
            } catch (error) {
                console.error('Error checking completed audits:', error);
                throw error; // Re-throw so refreshData can handle it
            }
        }

        // Start periodic status checking
        function startStatusChecking() {
            // Check every 30 seconds
            statusCheckInterval = setInterval(checkCompletedAudits, 30000);
        }

        // Refresh data
        function refreshData() {
            const loadingElement = document.getElementById('loading');
            loadingElement.style.display = 'block';
            
            // Flag that we're refreshing to prevent loadMeterData from hiding loading
            window.isRefreshing = true;
            
            // Also check for completed audits when refreshing
            checkCompletedAudits().then(() => {
                // After checking completed audits, reload meter data
                return loadMeterData();
            }).then(() => {
                // Ensure loading is hidden after everything completes
                window.isRefreshing = false;
                loadingElement.style.display = 'none';
            }).catch((error) => {
                console.error('Error during refresh:', error);
                // Always hide loading even if there's an error
                window.isRefreshing = false;
                loadingElement.style.display = 'none';
                showError('Error refreshing data: ' + error.message);
            });
        }

        // Show info message
        function showInfo(message) {
            const infoDiv = document.createElement('div');
            infoDiv.className = 'info-message';
            infoDiv.textContent = message;
            document.body.appendChild(infoDiv);

            setTimeout(() => {
                if (infoDiv.parentNode) {
                    infoDiv.parentNode.removeChild(infoDiv);
                }
            }, 4000);
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);

            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 6000);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>
